name: Site Monitoring

on:
  workflow_dispatch:
    inputs:
      site_url:
        description: "Site URL"
        required: false
        default: "https://neculaifantanaru.com"
  schedule:
    - cron: "17 4 * * *" # daily 04:17 UTC

jobs:
  monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r monitoring/requirements.txt

      - name: Configure site URL
        run: |
          echo "SITE_URL = \"${{ github.event.inputs.site_url || 'https://neculaifantanaru.com' }}\"" > monitoring/config.py

      - name: Run checks
        run: |
          python -c "import monitoring.run_all as r; r.run_all()"

      - name: Summarize report
        if: always()
        run: |
          if [ -f monitoring/.reports/summary.md ]; then
            echo "## Site Monitoring Summary" >> $GITHUB_STEP_SUMMARY
            cat monitoring/.reports/summary.md >> $GITHUB_STEP_SUMMARY
          else
            echo "No summary.md generated." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: site-monitoring-reports
          path: monitoring/.reports/
          if-no-files-found: ignore

      - name: Create or update Issue on problems
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'monitoring/.reports/aggregate.json';
            if (!fs.existsSync(path)) {
              core.info('No aggregate.json found; skipping issue creation.');
              return;
            }
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            const problems = [];
            if (!data.uptime?.ok) problems.push(`Uptime status ${data.uptime?.status} elapsed ${data.uptime?.elapsed_ms}ms`);
            if (data.ssl?.warn) problems.push(`SSL warn: days_left=${data.ssl?.days_left} error=${data.ssl?.error||''}`);
            if ((data.links?.broken_count||0) > 0) problems.push(`Broken links: ${data.links?.broken_count}`);
            if ((data.security?.missing||[]).length > 0) problems.push(`Missing headers: ${data.security?.missing.join(', ')}`);
            if ((data.robots?.issues||[]).length > 0) problems.push(`Robots/Sitemap issues: ${data.robots?.issues.join('; ')}`);
            if (!data.seo?.ok && (data.seo?.issues||[]).length > 0) problems.push(`SEO issues: ${data.seo.issues.length}`);
            if (!data.dns?.ok) problems.push(`DNS error: ${data.dns?.error||'unknown'}`);
            if (!data.images?.ok && (data.images?.issues||[]).length > 0) problems.push(`Image issues: ${data.images.issues.length}`);
            if (problems.length === 0) {
              core.info('No problems detected.');
              return;
            }
            const title = 'Site Monitoring Alerts';
            // Build details (top 20 broken links)
            let details = '';
            if ((data.links?.broken||[]).length > 0) {
              details += '\n\nTop broken links:';
              for (const item of data.links.broken.slice(0,20)) {
                if (item.status) details += `\n- ${item.url} — HTTP ${item.status}`;
                else details += `\n- ${item.url} — error: ${item.error||'unknown'}`;
              }
            }
            if ((data.security?.missing||[]).length > 0) {
              details += '\n\nMissing security headers:';
              for (const h of data.security.missing) details += `\n- ${h}`;
            }
            if ((data.seo?.issues||[]).length > 0) {
              details += '\n\nSEO issues:';
              for (const issue of data.seo.issues) details += `\n- ${issue}`;
            }
            if ((data.images?.issues||[]).length > 0) {
              details += '\n\nImage issues:';
              for (const issue of data.images.issues.slice(0,10)) {
                details += `\n- ${issue.url} — ${issue.error}`;
              }
            }
            const body = `Automated monitoring detected issues for ${data.site} at ${data.timestamp}.\n\n`+
              problems.map(p=>`- ${p}`).join('\n') + details +
              `\n\nArtifacts: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            // Find open issue with same title
            const issues = await github.rest.issues.listForRepo({owner: context.repo.owner, repo: context.repo.repo, state: 'open'});
            const existing = issues.data.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.createComment({owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, body});
            } else {
              await github.rest.issues.create({owner: context.repo.owner, repo: context.repo.repo, title, body, labels: ['monitoring','automated']});
            }
